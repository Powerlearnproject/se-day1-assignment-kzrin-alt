[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=19038427&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

software engineering is the application of engineering principles to the design, development, testing, deployment, and maintenance of software systems. it emphasizes structured processes, scalability, and reliability to build efficient, maintainable, and cost-effective software, all while reducing development risks and costs through structured methodologies


Identify and describe at least three key milestones in the evolution of software engineering.

1. the NATO conference on software engineering: this marked the formal recognition of software engineering as a discipline due to the "software crisis", when software complexity outpaced available development practices
2. introduction of object-oriented programming: languages like smalltalk and C++ introduced encapsulation, inheritance, and polymorphism
3. the agile manifesto: agile revolutionized software engineering by promoting flexibility, customer collaboration, and iterative development


List and briefly explain the phases of the Software Development Life Cycle.

- requirement analysis: understanding what the users need
- system design: structuring the system architecture and interfaces
- implementation: writing software code
- testing: verifying that the software works as intended
- deployment: Releasing the product to users
- maintenance: updates, bug fixes, and improvements


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

1. waterfall:
- linear process
- low flexibility
- heavy emphasis documentation
- limited customer involvement
- appropriate for fixed scope projects, i.e. aircraft navigation systems where safety is critical

2. agile:
- iterative process
- high flexibility
- lightweight documentation
- appropriate for evolving projects, i.e mobile e-commerce apps where user feedback drive frequent updates


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

1. software developer: debugging, software design writing code, implementing features, fixing bugs and collaborating with team members
2. quality assurance engineer: designing and executing tests, finding defects, ensuring the product meets quality standards
3. project manager: planning, coordinating team efforts, managing timelines and resources, stakeholder communication

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

1. IDEs increase productivity with features like auto-completion, real-time error checking and debugging tools by combining a code editor, debugger, compiler, and other tools into one. examples include visual studio, intellij idea and vs code
2. version control systems prevent code loss, support branching and merging for collaborative development by tracking changes to code. git is a good example


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

1. scope creep: can be solved by defining clear requirements and using change control processes
2. technical debt: solved by regular refactoring, code reviews and documentation
3. communication gaps: solved by clear documentation and collaborative tools
4. rapid technology changes: solved by continuous learning and community involvement


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

1. unit testing: tests individual functions or methods. ensures that small components work in isolation
2. integration testing: tests interactions between components or modules. catches interface-related bugs early
3. system testing: tests the complete system as a whole. validates that the system meets requirements
4. acceptance testing: tests whether the system meets business needs


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

this is a process that involve crafting clear, concise and structured inputs to get desired outputs from language models. It's essential for:
1. getting accurate and relevant answers
2. minimizing ambiguity and hallucination
3. optimizing performance for tasks

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

- vague prompt: "tell me about thoughtcrime and doublespeak"
- improved prompt: "decribe and outline the differences between doublethink and thoughcrime, expound on similar terminologies used in george orwell's 1984."
- why it is more effective: the prompt has more context and requests for organized and structured output with more relevant information
